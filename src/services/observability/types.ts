// kilocode_change - new file

import type { WasteAlertChannel, BudgetCurrency } from "../framework/types"

/**
 * Types of waste alerts that can be generated
 */
export type WasteAlertType =
	| "high_token_usage"
	| "no_progress"
	| "loop_detected"
	| "budget_exceeded"
	| "phase_budget_exceeded"
	| "repeated_errors"

/**
 * Severity level for alerts
 */
export type AlertSeverity = "info" | "warning" | "error" | "critical"

/**
 * Token usage metrics for tracking consumption
 */
export interface UsageMetrics {
	/** Total input tokens used */
	inputTokens: number
	/** Total output tokens used */
	outputTokens: number
	/** Total tokens (input + output) */
	totalTokens: number
	/** Cached tokens read from cache */
	cacheReadTokens: number
	/** Tokens written to cache */
	cacheWriteTokens: number
	/** Estimated cost in the specified currency */
	cost: number
	/** Timestamp of the metrics snapshot */
	timestamp: number
	/** Duration of the operation in milliseconds */
	duration: number
}

/**
 * Token usage thresholds for waste detection alerts
 */
export interface CostThresholds {
	/** Warning threshold - log notification (default: 15000 tokens) */
	warn: number
	/** Pause threshold - halt execution for review (default: 30000 tokens) */
	pause: number
	/** Maximum budget per task in the specified currency */
	maxTaskBudget: number
	/** Maximum budget per phase in the specified currency */
	maxPhaseBudget: number
}

/**
 * Configuration for waste detection
 */
export interface WasteDetectionOptions {
	/** Enable waste detection */
	enabled: boolean
	/** Token usage thresholds */
	thresholds: CostThresholds
	/** Enable loop detection for repeated errors */
	loopDetection: boolean
	/** Number of repeated errors to consider a loop */
	loopThreshold: number
	/** Time window in ms for loop detection */
	loopWindowMs: number
	/** Alert channels for notifications */
	alertChannels: WasteAlertChannel[]
	/** Currency for budget tracking */
	currency: BudgetCurrency
}

/**
 * Alert generated by waste detection
 */
export interface Alert {
	/** Unique identifier for the alert */
	id: string
	/** Type of waste alert */
	type: WasteAlertType
	/** Severity level */
	severity: AlertSeverity
	/** Human-readable message */
	message: string
	/** Timestamp when alert was generated */
	timestamp: number
	/** Related task ID if applicable */
	taskId?: string
	/** Related phase if applicable */
	phase?: string
	/** Usage metrics at time of alert */
	metrics?: UsageMetrics
	/** Additional context data */
	context?: Record<string, unknown>
}

/**
 * Progress indicator for tracking task advancement
 */
export interface ProgressIndicator {
	/** Number of successful tool calls */
	toolCallsSuccess: number
	/** Number of failed tool calls */
	toolCallsFailed: number
	/** Number of files modified */
	filesModified: number
	/** Number of files created */
	filesCreated: number
	/** Number of errors encountered */
	errorsCount: number
	/** Last activity timestamp */
	lastActivityTime: number
}

/**
 * Tracked operation for waste detection
 */
export interface TrackedOperation {
	/** Operation identifier */
	id: string
	/** Task ID this operation belongs to */
	taskId: string
	/** Phase name if applicable */
	phase?: string
	/** Operation description */
	description: string
	/** Start timestamp */
	startTime: number
	/** End timestamp (null if ongoing) */
	endTime: number | null
	/** Token usage for this operation */
	tokens: UsageMetrics
	/** Progress indicators */
	progress: ProgressIndicator
	/** Error messages encountered */
	errors: string[]
}

/**
 * Task cost record for tracking
 */
export interface TaskCostRecord {
	/** Task identifier */
	taskId: string
	/** Task description or prompt */
	description?: string
	/** Start timestamp */
	startTime: number
	/** End timestamp (null if ongoing) */
	endTime: number | null
	/** Total usage metrics */
	totalUsage: UsageMetrics
	/** Usage by model */
	modelUsage: Map<string, UsageMetrics>
	/** Phase breakdown */
	phaseUsage: Map<string, UsageMetrics>
	/** Budget limit for this task */
	budgetLimit: number
	/** Currency for this task */
	currency: BudgetCurrency
}

/**
 * Model pricing configuration
 */
export interface ModelPricing {
	/** Model identifier */
	modelId: string
	/** Cost per 1M input tokens */
	inputCostPerMillion: number
	/** Cost per 1M output tokens */
	outputCostPerMillion: number
	/** Cost per 1M cached read tokens (if applicable) */
	cacheReadCostPerMillion?: number
	/** Cost per 1M cached write tokens (if applicable) */
	cacheWriteCostPerMillion?: number
}

/**
 * Langfuse trace event
 */
export interface LangfuseTraceEvent {
	/** Trace identifier */
	traceId: string
	/** Span identifier */
	spanId?: string
	/** Event name */
	name: string
	/** Event timestamp */
	timestamp: number
	/** Event metadata */
	metadata?: Record<string, unknown>
	/** Input data */
	input?: unknown
	/** Output data */
	output?: unknown
	/** Usage metrics */
	usage?: Partial<UsageMetrics>
	/** Model identifier */
	model?: string
	/** Session identifier */
	sessionId?: string
	/** User identifier */
	userId?: string
}

/**
 * Langfuse span configuration
 */
export interface LangfuseSpanConfig {
	/** Span name */
	name: string
	/** Parent span ID if nested */
	parentSpanId?: string
	/** Start timestamp */
	startTime?: number
	/** Span metadata */
	metadata?: Record<string, unknown>
	/** Input data */
	input?: unknown
}

/**
 * Langfuse client configuration
 */
export interface LangfuseConfig {
	/** Langfuse public key */
	publicKey: string
	/** Langfuse secret key */
	secretKey: string
	/** Langfuse API base URL */
	baseUrl?: string
	/** Enable/disable tracing */
	enabled: boolean
	/** Flush interval in milliseconds */
	flushInterval?: number
	/** Maximum batch size for flushing */
	batchSize?: number
}

/**
 * Waste report generated for analysis
 */
export interface WasteReport {
	/** Report generation timestamp */
	timestamp: number
	/** Task ID this report covers */
	taskId: string
	/** Total tokens used */
	totalTokens: number
	/** Estimated cost */
	totalCost: number
	/** Duration in milliseconds */
	duration: number
	/** List of alerts generated */
	alerts: Alert[]
	/** Efficiency score (0-100) */
	efficiencyScore: number
	/** Recommendations for improvement */
	recommendations: string[]
	/** Token breakdown by operation */
	tokenBreakdown: Array<{
		operation: string
		tokens: number
		cost: number
		percentage: number
	}>
}

/**
 * Error record for loop detection
 */
export interface ErrorRecord {
	/** Error message */
	message: string
	/** Timestamp of occurrence */
	timestamp: number
	/** Operation ID where error occurred */
	operationId?: string
	/** Stack trace if available */
	stack?: string
}
