// kilocode_change - new file

/**
 * Bootstrap Configuration Writer
 *
 * This module provides functions to generate configuration files
 * for the Kilo Framework, including MCP server config, .framework/
 * directory structure, and default configuration files.
 */

import type { ConfigGenerationOptions, ConfigGenerationResult, McpServerConfig } from "./types"

// =============================================================================
// DEFAULT CONFIGURATIONS
// =============================================================================

/**
 * Default MCP server configurations
 */
export const DEFAULT_MCP_SERVERS: McpServerConfig[] = [
	{
		id: "codegraph-context",
		name: "CodeGraphContext",
		package: "@kilocode/mcp-codegraph-context",
		enabled: true,
		description: "Code graph context for enhanced code analysis",
	},
	{
		id: "rag-memory",
		name: "RAG Memory",
		package: "@kilocode/mcp-rag-memory",
		enabled: true,
		description: "RAG-based memory for context persistence",
	},
	{
		id: "taskmaster",
		name: "TaskMaster",
		package: "@kilocode/mcp-taskmaster",
		enabled: true,
		description: "Task management and orchestration",
	},
]

/**
 * Default framework configuration (YAML)
 */
export const DEFAULT_FRAMEWORK_CONFIG = `# Kilo Framework Configuration
# Generated by bootstrap process

framework:
  name: "Kilo Framework"
  version: "1.0.0"
  description: "AI Agentic Autonomous SDLC Framework"

sdlc:
  research:
    enabled: true
    timeout: 3600
    checkpoint_interval: 300
  planning:
    enabled: true
    timeout: 1800
    checkpoint_interval: 300
  implementation:
    enabled: true
    timeout: 7200
    checkpoint_interval: 600
    max_iterations: 10
  verification:
    enabled: true
    timeout: 3600
    checkpoint_interval: 300
    test_coverage_threshold: 80

scanner:
  enabled: true
  passes:
    - anti-patterns
    - architecture
    - performance
    - security
  continuous: false
  state_file: ".framework/scanner-state.md"
  repertoire_file: ".framework/scanner-repertoire.md"
  mcp_servers: []

waste_detection:
  enabled: true
  token_thresholds:
    warn: 50000
    pause: 100000
  loop_detection: true
  alert_channels:
    - console

cost_oversight:
  enabled: true
  budget_per_task: 10.00
  budget_per_phase: 50.00
  currency: USD
  langfuse_integration: false

webhooks:
  enabled: false
  port: 3000
  github:
    enabled: false
    secret: "\${GITHUB_WEBHOOK_SECRET}"
    events:
      - issues
      - pull_request

bootstrap:
  auto_check_updates: true
  mcp_servers:
    codegraph-context:
      enabled: true
      package: "@kilocode/mcp-codegraph-context"
    rag-memory:
      enabled: true
      package: "@kilocode/mcp-rag-memory"
    taskmaster:
      enabled: true
      package: "@kilocode/mcp-taskmaster"

modes:
  orchestrator:
    enabled: true
    config: ".kilo/modes/orchestrator.yaml"
  requirements:
    enabled: true
    config: ".kilo/modes/requirements.yaml"
  scanner:
    enabled: true
    config: ".kilo/modes/scanner.yaml"
  review:
    enabled: true
    config: ".kilo/modes/review.yaml"

voice:
  enabled: false
  personaPlex:
    enabled: false
    config_path: ".kilo/voice/personas.yaml"

logging:
  level: info
  output: ".framework/logs"
  rotation: daily
`

/**
 * Default MCP server configuration (JSON)
 */
export const DEFAULT_MCP_CONFIG = {
	version: "1.0.0",
	servers: Object.fromEntries(
		DEFAULT_MCP_SERVERS.map((s) => [
			s.id,
			{
				enabled: s.enabled,
				package: s.package,
			},
		]),
	),
}

/**
 * Default framework state (JSON)
 */
export const DEFAULT_FRAMEWORK_STATE = {
	framework_version: "1.0.0",
	created_at: new Date().toISOString(),
	updated_at: new Date().toISOString(),
	current_phase: null,
	phases: {
		research: { name: "research", active: false, tasks: [] },
		planning: { name: "planning", active: false, tasks: [] },
		implementation: { name: "implementation", active: false, tasks: [] },
		verification: { name: "verification", active: false, tasks: [] },
	},
	checkpoint_count: 0,
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

/**
 * Get the current working directory safely
 */
function getCwd(): string {
	const proc = (
		globalThis as unknown as {
			process?: {
				cwd?: () => string
			}
		}
	).process

	return proc?.cwd?.() ?? "."
}

/**
 * Ensure a directory exists
 */
async function ensureDir(dirPath: string): Promise<void> {
	const fs = await import("fs/promises")
	await fs.mkdir(dirPath, { recursive: true })
}

/**
 * Check if a file exists
 */
async function fileExists(filePath: string): Promise<boolean> {
	try {
		const fs = await import("fs/promises")
		await fs.access(filePath)
		return true
	} catch {
		return false
	}
}

/**
 * Write a file if it doesn't exist or if overwrite is true
 */
async function writeFile(
	filePath: string,
	content: string,
	overwrite: boolean,
): Promise<{ written: boolean; reason?: string }> {
	try {
		const exists = await fileExists(filePath)
		if (exists && !overwrite) {
			return { written: false, reason: "File already exists" }
		}

		const fs = await import("fs/promises")
		await fs.writeFile(filePath, content, "utf-8")
		return { written: true }
	} catch (error) {
		return {
			written: false,
			reason: error instanceof Error ? error.message : String(error),
		}
	}
}

// =============================================================================
// CONFIGURATION GENERATION FUNCTIONS
// =============================================================================

/**
 * Generate MCP server configuration
 */
export async function generateMcpConfig(
	workspacePath: string,
	options: ConfigGenerationOptions,
): Promise<ConfigGenerationResult> {
	const startTime = Date.now()

	try {
		const path = await import("path")

		const mcpDir = path.join(workspacePath, ".kilocode", "mcp")
		await ensureDir(mcpDir)

		const configPath = path.join(mcpDir, "servers.json")
		const content = JSON.stringify(DEFAULT_MCP_CONFIG, null, 2)

		const result = await writeFile(configPath, content, options.overwrite)

		return {
			path: configPath,
			success: result.written,
			created: result.written,
			error: result.reason,
		}
	} catch (error) {
		return {
			path: "",
			success: false,
			created: false,
			error: error instanceof Error ? error.message : String(error),
		}
	}
}

/**
 * Generate .framework directory structure
 */
export async function generateFrameworkDir(
	workspacePath: string,
	options: ConfigGenerationOptions,
): Promise<ConfigGenerationResult[]> {
	const results: ConfigGenerationResult[] = []

	try {
		const path = await import("path")

		const frameworkDir = path.join(workspacePath, ".framework")
		await ensureDir(frameworkDir)

		// Create subdirectories
		const subdirs = ["logs", "checkpoints", "cache"]
		for (const subdir of subdirs) {
			await ensureDir(path.join(frameworkDir, subdir))
		}

		// Generate config.yaml
		const configPath = path.join(frameworkDir, "config.yaml")
		const configResult = await writeFile(configPath, DEFAULT_FRAMEWORK_CONFIG, options.overwrite)
		results.push({
			path: configPath,
			success: configResult.written,
			created: configResult.written,
			error: configResult.reason,
		})

		// Generate state.json
		const statePath = path.join(frameworkDir, "state.json")
		const stateResult = await writeFile(
			statePath,
			JSON.stringify(DEFAULT_FRAMEWORK_STATE, null, 2),
			false, // Never overwrite state
		)
		results.push({
			path: statePath,
			success: stateResult.written,
			created: stateResult.written,
			error: stateResult.reason,
		})

		return results
	} catch (error) {
		results.push({
			path: "",
			success: false,
			created: false,
			error: error instanceof Error ? error.message : String(error),
		})
		return results
	}
}

/**
 * Generate logging directory
 */
export async function generateLoggingDir(workspacePath: string): Promise<ConfigGenerationResult> {
	try {
		const path = await import("path")

		const logsDir = path.join(workspacePath, ".framework", "logs")
		await ensureDir(logsDir)

		// Create a .gitkeep file to ensure the directory is tracked
		const gitkeepPath = path.join(logsDir, ".gitkeep")
		const exists = await fileExists(gitkeepPath)
		if (!exists) {
			const fs = await import("fs/promises")
			await fs.writeFile(gitkeepPath, "", "utf-8")
		}

		return {
			path: logsDir,
			success: true,
			created: true,
		}
	} catch (error) {
		return {
			path: "",
			success: false,
			created: false,
			error: error instanceof Error ? error.message : String(error),
		}
	}
}

/**
 * Generate all configuration files
 */
export async function generateAllConfigs(
	options: ConfigGenerationOptions,
	workspacePath?: string,
): Promise<ConfigGenerationResult[]> {
	const results: ConfigGenerationResult[] = []
	const targetPath = workspacePath ?? getCwd()

	// Generate .framework directory and config files
	const frameworkResults = await generateFrameworkDir(targetPath, options)
	results.push(...frameworkResults)

	// Generate MCP configuration
	const mcpResult = await generateMcpConfig(targetPath, options)
	results.push(mcpResult)

	// Generate logging directory
	if (options.createLoggingDir) {
		const logsResult = await generateLoggingDir(targetPath)
		results.push(logsResult)
	}

	return results
}

/**
 * Get summary of configuration generation results
 */
export function getConfigGenerationSummary(results: ConfigGenerationResult[]): {
	generated: number
	skipped: number
	failed: number
	total: number
} {
	let generated = 0
	let skipped = 0
	let failed = 0

	for (const result of results) {
		if (result.success) {
			if (result.created) {
				generated++
			} else {
				skipped++
			}
		} else {
			failed++
		}
	}

	return {
		generated,
		skipped,
		failed,
		total: results.length,
	}
}

/**
 * Generate .gitignore entries for framework files
 */
export const GITIGNORE_ENTRIES = [
	"# Kilo Framework",
	".framework/logs/",
	".framework/cache/",
	".framework/checkpoints/",
	".framework/state.json",
	"",
	"# Keep important files",
	"!.framework/config.yaml",
	"!.framework/scanner-state.md",
	"!.framework/scanner-repertoire.md",
]

/**
 * Update .gitignore with framework entries
 */
export async function updateGitignore(workspacePath: string): Promise<ConfigGenerationResult> {
	try {
		const path = await import("path")
		const fs = await import("fs/promises")

		const gitignorePath = path.join(workspacePath, ".gitignore")

		let existingContent = ""
		try {
			existingContent = await fs.readFile(gitignorePath, "utf-8")
		} catch {
			// File doesn't exist, will create it
		}

		// Check if our entries already exist
		if (existingContent.includes("# Kilo Framework")) {
			return {
				path: gitignorePath,
				success: true,
				created: false,
			}
		}

		// Append our entries
		const newContent = existingContent
			? `${existingContent}\n\n${GITIGNORE_ENTRIES.join("\n")}\n`
			: `${GITIGNORE_ENTRIES.join("\n")}\n`

		await fs.writeFile(gitignorePath, newContent, "utf-8")

		return {
			path: gitignorePath,
			success: true,
			created: !existingContent,
		}
	} catch (error) {
		return {
			path: "",
			success: false,
			created: false,
			error: error instanceof Error ? error.message : String(error),
		}
	}
}
